#!/usr/bin/python
#
# Copyright (C) 2007 Julian Andres Klode <jak@jak-linux.org>
# Copyright (C) 2003-2006 Darren Kirby <d@badcomputer.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

'''
dir2ogg converts mp3, m4a, and wav files to the free open source OGG format. Oggs are
about 20-25% smaller than mp3s with the same relative sound quality. Your mileage may vary.

Keep in mind that converting from mp3 or m4a to ogg is a conversion between two lossy formats.
This is fine if you just want to free up some disk space, but if you're a hard-core audiophile
you may be dissapointed. I really can't notice a difference in quality with 'naked' ears myself.

This script converts mp3s to wavs using mpg123 then converts the wavs to oggs using oggenc.
m4a conversions require faad. Id3 tag support requires mutagen for mp3s.
Scratch tags using the filename will be written for wav files (and mp3s with no tags!)
'''

import sys
import os, os.path
import string
import re
from fnmatch import filter, fnmatch
from optparse import OptionParser
from subprocess import Popen, call, PIPE

__version__ = '0.11alpha3'
__date__    = '2007-08-12'

class MyConfig:
    def __init__(self):
        showBanner()
        if 'alpha' in __version__ or 'beta' in __version__:
            warn('This is a pre-release, the behaviour may change in future pre-releases')
        if '-f' in sys.argv:
            warn('-f is deprecated and its behavior will change in 0.12. Please use -W in future')
        if len(sys.argv[1:]) == 0:
            fatal('No arguments specified, see --help for usage.')
        parser = OptionParser(usage='%prog [options] [arguments]', version='%prog ' + __version__)
        parser.add_option('-l', '--license',action='callback', callback=showLicense, help='display license informations')
        parser.add_option('-d', '--directory', action='store_true', help='convert files in all directories specified as arguments')
        parser.add_option('-r', '--recursive', action='store_true', help='convert files in all subdirectories of all directories specified as arguments')
        parser.add_option('-c', '--cdda', action='store_true', help="convert audio cd in all devices specified as arguments (or default: /dev/cdrom) [EXPERIMENTAL]")
        parser.add_option('-q', '--quality', metavar='N', default=3.0, type='float', help='quality. N is a number from 1-10 (default %default)')
        parser.add_option('-n', '--no-mp3', dest='convert_mp3', action='store_false', default=True, help="don't convert mp3s (use with '-d' or '-r')")
        parser.add_option('--convert-flac',action='store_true', help="convert flac files (use with '-d')")
        parser.add_option('-m', '--convert-m4a', action='store_true', help="convert m4a files (use with '-d')")
        parser.add_option('-w', '--convert-wav', action='store_true', help="convert wav files (use with '-d')")
        parser.add_option('-f', '-W', '--convert-wma', action='store_true', help="convert wma files (use with '-d').")
        parser.add_option('--delete-input', action='store_true', help='delete input files')
        parser.add_option('-p', '--preserve-wav',action='store_true', help='keep the wav files (also includes -P)')
        parser.add_option('-P', '--no-pipe',action='store_true', help='Do not use pipes, use temporary wav files')
        parser.add_option('-v', '--verbose',action='store_true', help='verbose output')
        options, self.args = parser.parse_args()
        if filter(self.args, '*.[mM][pP]3') :
            options.convert_mp3 = True
        elif filter(self.args, '*.[mM]4[aA]'):
            options.convert_m4a = True
        elif filter(self.args, '*.[wW][mM][aA]'):
            options.convert_wma = True
        elif filter(self.args, '*.[fF][lL][aA][cC]'):
            options.convert_flac = True
        self.__dict__.update(options.__dict__)
        self.convert_cd = self.cdda
        self.checkDecoder()
        if len(self.args) == 0 and not self.cdda:
            fatal('No files/directories specified.')

    def checkDecoder(self):
        '''Set the decoder'''
        commands = {'mp3': ('mpg123', 'mpg321', 'mplayer'),
                    'wma': ('mplayer',),
                    'm4a': ('faad', 'mplayer'),
                    'flac': ('flac', 'ogg123', 'mplayer'),
                    'cd':  ('cdparanoia', 'icedax','cdda2wav')
                   }
        for ext, dec in commands.items():
            self.__dict__[ext + '_decoder'] = None
            for command in dec:
                a = [prefix for prefix in os.environ['PATH'].split(os.pathsep) if os.path.exists(os.path.join(prefix, command))]
                if a:
                    self.__dict__[ext + '_decoder'] = command
                    break
        for ext in commands:
            if self.__dict__["convert_" + ext] and not self.__dict__[ext + '_decoder']:
                fatal('%s was enabled, but no decoder has been found.' % ext)

def info(msg):
    print 'I: %s' % msg

def warn(msg, i="W:", e=''):
    '''print errors to the screen (red)'''
    call(['echo', '-en', '\\033[1;31m'])
    print >> sys.stderr, "%s %s %s" % (i, msg, e)
    call(['echo', '-en', '\\033[0;39m'])

def fatal(msg):
    '''Fatal error (error + exit)'''
    warn(msg, 'E:', 'Exiting...')
    sys.exit(1)
error = warn

def returnDirs(root):
    mydirs = {}
    for pdir, dirs, files in os.walk(root):
        if not pdir in mydirs:
            mydirs[pdir] = files
    return mydirs

class Id3TagHandler:
    '''Class for handling meta-tags. (Needs mutagen)'''
    accept = ['artist', 'title', 'album', 'date', 'comment', 'genre', 'tracknumber', 'tracktotal', 'discid', 'musicbrainz_discid', 'musicbrainz_sortname']
    tags   = {}
    def grabCommon(self, handler, convert={}):
        '''Common grabber, starts the handler and applies the tags to self.tags'''
        mydict = handler(self.song)
        for k,v in mydict.items():
            k = k.lower()
            k = k in convert and convert[k] or k
            if k in self.accept:
                self.tags[k] = v
            else:
                print k

    def grabM4ATags(self):
        '''Import MP4 tags handler, set convert and call commonGrab'''
        convert = {'\xa9alb': 'album', '\xa9art': 'artist', '\xa9day': 'date', '\xa9nam': 'title', 'trkn': 'tracknumber',
                        '\xa9gen': 'genre', '\xa9cmt': 'comment'}
        try:
            from mutagen.mp4 import MP4
        except ImportError:
            from mutagen.m4a import M4A as MP4
        self.grabCommon(MP4, convert)

    def grabM4ATags(self):
        '''Import MP4 tags handler, set convert and call commonGrab'''
        convert = {'\xa9alb': 'album', '\xa9art': 'artist', '\xa9day': 'date', '\xa9nam': 'title', 'trkn': 'tracknumber',
                        '\xa9gen': 'genre', '\xa9cmt': 'comment'}
        try:
            from mutagen.mp4 import MP4
        except ImportError:
            from mutagen.m4a import M4A as MP4
        self.grabCommon(MP4, convert)

    def grabWMATags(self):
        '''Import ASF tags handler, set convert and call commonGrab'''
        convert = {'Author': 'artist',  'AlbumTitle': 'album', 'Year': 'date'}
        from mutagen.asf import ASF
        self.grabCommon(ASF, convert)

    def grabFLACTags(self):
        '''Import MP3 tags handler, and call commonGrab'''
        from mutagen.flac import FLAC
        self.grabCommon(FLAC)

    def grabMP3Tags(self):
        '''Import MP3 tags handler, and call commonGrab'''
        from mutagen.easyid3 import EasyID3
        self.grabCommon(EasyID3)

    def listIfVerbose(self):
        info('Meta-tags I will write:')
        for k,v in self.tags.items():
            if type(v) == list:
                info(k + ': ' + ','.join(v))
            else:
                info(k + ': ' + v)

class Convert(Id3TagHandler):
    '''
    Base conversion Class.

    __init__ creates some useful attributes,
    grabs the id3 tags, and sets a flag to remove files.
    Methods are the conversions we can do
    '''

    def __init__(self, song, conf):
        self.song    = song
        self.conf    = conf
        songRoot     = os.path.splitext(song)[0] + "."
        self.songwav = songRoot + 'wav'
        self.songogg = songRoot + 'ogg'
        self.BUFFER  = '#' * 78
        if fnmatch(self.song, '*.[mM][pP]3') :
            self.decoder = self.conf.mp3_decoder
            self.grabMP3Tags()
        elif fnmatch(self.song, '*.[mM]4[aA]'):
            self.decoder = self.conf.m4a_decoder
            self.grabM4ATags()
        elif fnmatch(self.song, '*.[wW][mM][aA]'):
            self.decoder = self.conf.wma_decoder
            self.grabWMATags()
        elif fnmatch(self.song, '*.[fF][lL][aA][cC]'):
            self.decoder = self.conf.flac_decoder
            self.grabFLACTags()
        self.convert()

    def decode(self):
        if self.decoder != 'mplayer' and not self.conf.no_pipe and not self.conf.preserve_wav:
            outfile, outfile1 = '-', '/dev/stdout'
            use_pipe = 1
        else:
            outfile = outfile1 = self.songwav
            use_pipe = 0
        decoder            = {}
        decoder['mpg123']  = ['mpg123', '-w', outfile, self.song]
        decoder['mpg321']  = ['mpg321', '-w', outfile, self.song]
        decoder['faad']    = ['faad',  '-o' , outfile1, self.song]
        decoder['ogg123']  = ['ogg123', '-dwav', '-f' , outfile, self.song]
        decoder['flac']    = ['flac', '-o', outfile, '-d', self.song]
        decoder['mplayer'] = ['mplayer', '-vo', 'null', '-vc' ,'dummy', '-af', 'resample=44100', '-ao', 'pcm:file=' + outfile, self.song]

        if use_pipe:
            return True, Popen(decoder[self.decoder], stdout=PIPE)
        else:
            retcode = call(decoder[self.decoder])
            if retcode != 0:
                return (False, None)
            else:
                return (True, None)

    def convert(self):
        ''' Convert wav -> ogg.'''
        if self.songwav == self.song:
            ok = True
            dec = None
        else:
            ok, dec = self.decode()
        if not ok:
            error('Decoding of "%s" failed.' % self.song)
            return

        if dec:
            enc = Popen(['oggenc', '-o', self.songogg, '-q', str(self.conf.quality), '-'], stdin=dec.stdout)
            enc.communicate()
            dec.wait()
            if dec.returncode < 0:
                error('Decoding of "%s" failed.' % self.song)
                return False
            elif enc.returncode < 0:
                error('Encoding of "%s" failed.' % self.song)
                return False
        else:
            enc = call(['oggenc', '-o', self.songogg, '-q', str(self.conf.quality), self.songwav])
            if enc != 0:
                error('Encoding of "%s" failed.' % self.songwav)
                return False
            elif not self.conf.preserve_wav and self.song != self.songwav:
                os.remove(self.songwav)
        if self.tags != {}:
            try:
                # Add tags to the ogg file
                from mutagen.oggvorbis import OggVorbis
                myogg = OggVorbis(self.songogg)
                myogg.update(self.tags)
                myogg.save()
            except:
                error('Could not save the tags')
                return False
        else:
            warn('No tags found...')

        if self.conf.delete_input:
            os.remove(self.song)
        return True

class ConvertTrack(Convert):
    '''Wrapper around Convert for CD Tracks'''
    def __init__(self, device, conf, track, tags):
        self.device, self.track, self.tags, self.conf = device, track, tags, conf
        self.song    = ''
        self.songwav = "audio.wav"
        self.songogg = "%(artist)s/%(album)s/%(ntracknumber)s - %(title)s.ogg" % tags
        self.conf.preserve_wav = False
        self.convert()

    def decode(self):
        cmd               = {}
        cmd['cdparanoia'] = ['cdparanoia', '-Y', '-q',  '-w', '-d', self.device, str(self.track), '-']
        cmd['icedax']     = ['icedax', '-H', '-t', str(self.track), '-D',self.device]
        cmd['cdda2wav']   = ['cdda2wav', '-H', '-t', str(self.track), '-D',self.device]
        if self.conf.cd_decoder != 'cdparanoia':
            retcode = call(cmd[self.conf.cd_decoder])
            if retcode != 0:
                return (False, None)
            else:
                return (True, None)
        else:
            return True, Popen(cmd[self.conf.cd_decoder], stdout=PIPE)

class ConvertDisc:
    '''Wrapper around ConvertTrack to Convert complete cds
    Currently uses MusicBrainz, but a CDDB fallback will be added, too.'''
    def __init__(self, dev, conf):
        self.dev, self.conf = dev, conf
        try:
            self.MusicBrainz()
        except self.MBError:
            warn('MusicBrainz failed. Trying FreeDB...')
            self.CDDB()
    class MBError:
        '''Empty'''

    def CDDB(self):
        try:
            import CDDB, DiscID
        except ImportError:
            fatal('You need python-cddb (http://cddb-py.sf.net) to convert cds. Please install it.')
            
        cdrom = DiscID.open(self.dev)
        disc_id = DiscID.disc_id(cdrom)
        print  '%08lx' % long(DiscID.disc_id(DiscID.open(self.dev))[0])
        (query_status, query_info) = CDDB.query(disc_id)
        if type(query_info) == list:
            query_info = query_info[0]
        (read_status, read_info) = CDDB.read(query_info['category'], query_info['disc_id'])

        for i in range(disc_id[1]):
            title           = {}
            title['discid'] = query_info['disc_id']
            title['artist'],title['album'] = (i.strip() for i in query_info['title'].split("/"))
            title['genre']  = read_info['DGENRE']
            title['date']   = read_info['DYEAR']
            title['title']  = read_info['TTITLE' + str(i)]          
            title['tracktotal'] = str(len(range(disc_id[1])))
            title['ntracknumber'] = '0' * (len(title['tracktotal'] ) - len(str(i+1)) ) + str(i+1)
            title['tracknumber'] = str(i+1)
            for k, v in title.items():
                title[k] =  unicode(str(v), "ISO-8859-1")
            ConvertTrack(self.dev, self.conf, i+1, title)
            
    def MusicBrainz(self):
        try:
            import musicbrainz2.disc as mbdisc
            import musicbrainz2.webservice as mbws
        except ImportError, e:
            error('You need python-musicbrainz2 to convert cds. Please install it. Trying cddb.')
            raise self.MBError, e

        service = mbws.WebService()
        query = mbws.Query(service)

        # Read the disc in the drive
        try:
            disc = mbdisc.readDisc(self.dev)
        except mbdisc.DiscError, e:
            print "Error:", e
            sys.exit(1)

        discId = disc.getId()
        try:
            myfilter = mbws.ReleaseFilter(discId=discId)
            results = query.getReleases(myfilter)
        except mbws.WebServiceError, e:
            print "Error:", e
            raise self.MBError

        if len(results) == 0:
            print "Disc is not yet in the MusicBrainz database."
            print "Consider adding it via", mbdisc.getSubmissionUrl(disc)
            raise self.MBError
        try:
            inc = mbws.ReleaseIncludes(artist=True, tracks=True, releaseEvents=True)
            release = query.getReleaseById(results[0].release.getId(), inc)
        except mbws.WebServiceError, e:
            print "Error:", e
            raise self.MBError
            
        isSingleArtist = release.isSingleArtistRelease()
        
        try:
            # try to get the CDDB ID
            import DiscID
            cddb_id = '%08lx' % long(DiscID.disc_id(DiscID.open(self.dev))[0])
        except:
            cddb_id = False
            pass

        i = 1
        for t in release.tracks:

            title           = {}
            title['artist'] = isSingleArtist and release.artist.name or t.artist
            if cddb_id:
                title['discid'] = cddb_id
            title['album']  = release.title
            title['date']   = release.getEarliestReleaseDate()
            title['musicbrainz_albumartistid'] = release.artist.id.split("/")[-1]
            title['musicbrainz_albumid'] = release.id.split("/")[-1]
            title['musicbrainz_discid'] = discId
            title['musicbrainz_sortname'] = release.artist.sortName
            title['musicbrainz_trackid'] = t.id.split("/")[-1]
            title['title']  = t.title
            title['tracktotal'] = str(len(release.tracks))
            title['ntracknumber'] = '0' * ( len(title['tracktotal']) - len(str(i)) ) + str(i)
            title['tracknumber'] = str(i)

            ConvertTrack(self.dev, self.conf, i, title)
            i+=1

class ConvertDirectory:
    '''
    This class is just a wrapper for Convert.
    
    Grab the songs to convert, then feed them one
    by one to the Convert class.
    '''

    def __init__(self, conf, d, files=None):
        ''' Decide which files will be converted.'''
        if os.path.exists(d) == 0:
            error('Directory: "%s" not found' % d)
            sys.exit(1)

        self.d = d = os.path.normpath(d) + os.path.sep
        self.songs = files and files or os.listdir(d)
        self.m4as  = conf.convert_m4a and filter(self.songs, '*.[mM]4[aA]') or []
        self.mp3s  = conf.convert_mp3 and filter(self.songs, '*.[mM][pP]3') or []
        self.wavs  = conf.convert_wav and filter(self.songs, '*.[wW][aA][vV]') or []
        self.wmas  = conf.convert_wma and filter(self.songs, '*.[wW][mM][aA]') or []
        self.flacs = conf.convert_flac and filter(self.songs, '*.[fF][lL][aA][cC]') or []

        if conf.verbose:
            self.printIfVerbose(conf)

        for f in self.wmas +  self.mp3s + self.wavs + self.m4as + self.flacs:
            Convert(d + f, conf)

    def printIfVerbose(self, conf):
        ''' Echo files to be converted if verbose flag is set.'''
        info('In %s I am going to convert:' % self.d)
        if conf.convert_mp3:
            for mp3 in self.mp3s:
                info(mp3)
            if len(self.mp3s) == 0:
                warn('No mp3s in %s' % self.d)
        if conf.convert_flac:
            for flac in self.flacs:
                info(flac)
            if len(self.flacs) == 0:
                warn('No flacs in %s' % self.d)
        if conf.convert_m4a:
            for m4a in self.m4as:
                info(m4a)
            if len(self.m4as) == 0:
                warn('No m4as in %s' % self.d)
        if conf.convert_wma:
            for wma in self.wmas:
                info(wma)
            if len(self.wmas) == 0:
                warn('No wmas in %s' % self.d)
        if conf.convert_wav:
            for wav in self.wavs:
                info(wav)
            if len(self.wavs) == 0:
                warn('No wavs in %s' % self.d)
        print


def showBanner():
    print 'dir2ogg %s, (C) Julian Andres Klode and Darren Kirby. Released under GPL' % __version__
    print

def showLicense(*args, **kwargs):
    print 'dir2ogg %s; released %s ' % (__version__, __date__)
    print 'Copyright (C) 2007 Julian Andres Klode <jak@jak-linux.org>'
    print 'Copyright (C) 2003-2006 Darren Kirby <d@badcomputer.org>'
    print
    print 'This program is distributed in the hope that it will be useful,'
    print 'but WITHOUT ANY WARRANTY; without even the implied warranty of'
    print 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the'
    print 'GNU General Public License for more details.'
    print
    print 'Currently developed by Julian Andres Klode <jak@jak-linux.org>.'
    sys.exit(0)

def main():
    conf = MyConfig()
    if conf.recursive:
        rdirs = {}
        for d in conf.args:
            if os.path.exists(d) == 0:
                error('Directory: "%s" not found' % d)
                sys.exit(1)
            l = returnDirs(d)
            rdirs.update(l)
        if len(rdirs) == 0:
            error('No files to convert!')
            sys.exit(1)
        for directory,files in rdirs.items():
            ConvertDirectory(conf, directory, files)

    elif conf.directory:
        for d in conf.args:
            if os.path.exists(d) == 0:
                error('Directory: "%s" not found' % s)
                sys.exit(1)
        for d in conf.args:
            ConvertDirectory(conf, d)

    elif conf.cdda:
        discs = len(conf.args) and conf.args or ("/dev/cdrom",)
        for disc in discs:
            ConvertDisc(disc, conf)
    else:
        for s in conf.args:
            if os.path.exists(s) == 0:
                error('File: "%s" not found' % s)
                sys.exit(1)
        for s in conf.args:
            Convert(s, conf)

    sys.exit(0)

if __name__ == '__main__':
    main()
